{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/articles/supporting-os-appearance-settings-in-your-web-app","result":{"pageContext":{"id":"Xo3GzxAAACIAJj0C","uid":null,"type":"blog_article","href":"https://uxblog.cdn.prismic.io/api/v2/documents/search?ref=XpwWZBEAACUAkYjp&q=%5B%5B%3Ad+%3D+at%28document.id%2C+%22Xo3GzxAAACIAJj0C%22%29+%5D%5D","tags":["css","custom properties","sass"," themes"],"first_publication_date":"2020-04-08T12:47:23+0000","last_publication_date":"2020-04-19T09:14:12+0000","slugs":["supporting-os-appearance-settings-in-your-web-app","supporting-os-appearance-settings-in-your-app"],"linked_documents":[],"lang":"en-us","alternate_languages":[],"data":{"title":[{"type":"heading1","text":"Supporting OS appearance settings in your web app","spans":[]}],"subtitle":[{"type":"heading2","text":"Theming a web application to respond to appearance settings through media queries, CSS custom properties, and Sass variables.","spans":[]}],"authored_by":{"id":"Xk3iiBEAACUAeaL0","type":"author","tags":["author"],"slug":"stephen-seator","lang":"en-us","link_type":"Document","isBroken":false},"body":[{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"There's been a big trend in town for a while now that I have been meaning to explore.","spans":[]},{"type":"paragraph","text":"Dark mode.","spans":[{"start":0,"end":10,"type":"strong"}]},{"type":"embed","oembed":{"url":"https://media.giphy.com/media/229XocXgYTvIk/giphy.gif","embed_url":"https://media.giphy.com/media/229XocXgYTvIk/giphy.gif","type":"rich","version":"1.0","title":null,"author_name":null,"author_url":null,"provider_name":"static_image","provider_url":null,"cache_age":null,"thumbnail_url":"https://media.giphy.com/media/229XocXgYTvIk/giphy.gif","thumbnail_width":null,"thumbnail_height":null,"html":"<div data-type=\"static_image\"><img src=\"https://media.giphy.com/media/229XocXgYTvIk/giphy.gif\"></div>"}},{"type":"paragraph","text":"Not knowing much about the subject as far as implementation and browser support, I did what any clueless developer would do. Consult the search engines!","spans":[]},{"type":"paragraph","text":"Before we begin 'solutioning', allow me to present a list of some of my initial expectations the solution should support:","spans":[]},{"type":"list-item","text":"Must be able to derive state from user's OS preferences","spans":[]},{"type":"list-item","text":"Must be able to respond in real time to any changes to those preferences","spans":[]},{"type":"list-item","text":"Must not require individual media queries to apply themes at the component level","spans":[]},{"type":"list-item","text":"Must be composable to support authoring of complex rules","spans":[]},{"type":"paragraph","text":"It's all about that DX (developer experience)! ","spans":[{"start":20,"end":22,"type":"label","data":{"label":"strong"}},{"start":20,"end":22,"type":"strong"}]},{"type":"paragraph","text":"This can be accomplished both via JavaScript (enabling support for CSS-in-JS libraries), and CSS (optionally in conjunction with your pre-processor of choice). My preference of the two is utilizing CSS modules, and is what I will be focusing on in this article. Similar principles and strategies should still apply regardless of your preference.","spans":[]}]}},{"slice_type":"horizontal_rule","slice_label":null,"items":[{}],"primary":{}},{"slice_type":"section_title","slice_label":null,"items":[{}],"primary":{"section_title":[{"type":"heading3","text":"Establish a palette","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"I've been known to change my mind on aesthetic choices from time to time. When working with design systems and style guides in early stages of maturity, tweaks and adjustments are perhaps inevitable. Abstracting out palette definitions from their application throughout the UI is a strategy I would highly recommend! This makes life far less complicated when working with a style guide in a frequent state of flux, as our definitions can be adjusted in one tidy place.","spans":[]},{"type":"paragraph","text":"Pre-processors afford us the luxury of defining an array of value types, such as variables, lists, maps and even functions. They are powerful tools we hold in our repertoire, so let's use them! Within Sass, let's establish a map of palette entries to be used throughout our application.","spans":[]},{"type":"paragraph","text":"If you aren't familiar with List and Map support in Sass, here's a quick primer on value types, indexing, and access.","spans":[{"start":28,"end":32,"type":"label","data":{"label":"code"}},{"start":37,"end":40,"type":"label","data":{"label":"code"}},{"start":65,"end":79,"type":"hyperlink","data":{"link_type":"Web","url":"https://sass-lang.com/documentation/values"}}]}]}},{"slice_type":"code_snippet","slice_label":null,"items":[{}],"primary":{"filename":"./src/styles/themes.scss","highlight":"scss","code":[{"type":"preformatted","text":"$palette: (\n  \"black\": #11120E,\n  \"white\": #FFFFFF,\n  \"blue\": #0973D6,\n  \"orange\": #FF9A1F\n);","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"","spans":[]},{"type":"paragraph","text":"I've opted to start simply with a limited number of values. Style guides often define a variance of grayscale values which complement core palette entries which represent the brand. Feel free to define those and other key palette entries here. I will be generating my grayscale values via Sass color functions.","spans":[{"start":294,"end":310,"type":"hyperlink","data":{"link_type":"Web","url":"https://sass-lang.com/documentation/values/colors"}}]}]}},{"slice_type":"horizontal_rule","slice_label":null,"items":[{}],"primary":{}},{"slice_type":"section_title","slice_label":null,"items":[{}],"primary":{"section_title":[{"type":"heading3","text":"Defining themes","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"I want to express any given theme as a Sass Map with a consistent model. If i were to define a key named myColor in the model, themeA.myColor and themeB.myColor should both map to a Sass color appropriate for each theme respectively.","spans":[{"start":44,"end":47,"type":"label","data":{"label":"code"}},{"start":105,"end":112,"type":"label","data":{"label":"code"}},{"start":127,"end":141,"type":"label","data":{"label":"code"}},{"start":146,"end":160,"type":"label","data":{"label":"code"}}]},{"type":"paragraph","text":"I will need a theme to support both light and dark appearance settings depending on a user's OS configuration.","spans":[{"start":36,"end":41,"type":"label","data":{"label":"code"}},{"start":46,"end":50,"type":"label","data":{"label":"code"}}]}]}},{"slice_type":"code_snippet","slice_label":null,"items":[{}],"primary":{"filename":"./src/styles/themes.scss","highlight":"scss","code":[{"type":"preformatted","text":"// dark theme value map\n$dark-theme: (\n  background-0: map-get($palette, \"black\"),\n  background-1: desaturate(lighten(map-get($palette, \"black\"), 5%), 50%),\n  background-2: desaturate(lighten(map-get($palette, \"black\"), 12%), 35%),\n  neutral: desaturate(lighten(map-get($palette, \"black\"), 50%), 28%),\n  foreground: map-get($palette, \"white\"),\n);\n\n// light theme value map\n$light-theme: (\n  background-0: map-get($palette, \"white\"),\n  background-1: desaturate(lighten(map-get($palette, \"black\"), 88%), 10%),\n  background-2: desaturate(lighten(map-get($palette, \"black\"), 80%), 20%),\n  neutral: desaturate(lighten(map-get($palette, \"black\"), 30%), 28%),\n  foreground: map-get($palette, \"black\"),\n  primary: map-get($palette, \"blue\")\n);","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"First thing you might notice from this snippet are the key names used within the map.","spans":[]},{"type":"embed","oembed":{"url":"https://media.giphy.com/media/14uRnBOrCwkOMU/giphy.gif","embed_url":"https://media.giphy.com/media/14uRnBOrCwkOMU/giphy.gif","type":"rich","version":"1.0","title":null,"author_name":null,"author_url":null,"provider_name":"static_image","provider_url":null,"cache_age":null,"thumbnail_url":"https://media.giphy.com/media/14uRnBOrCwkOMU/giphy.gif","thumbnail_width":null,"thumbnail_height":null,"html":"<div data-type=\"static_image\"><img src=\"https://media.giphy.com/media/14uRnBOrCwkOMU/giphy.gif\"></div>"}},{"type":"paragraph","text":"I tend to avoid using specific color names for key names within the model. ","spans":[]},{"type":"paragraph","text":"The logic behind this is quite simple. By principle, our model and the corresponding key names remain fixed. However, the corresponding value may be unique for each theme. Choosing relativistic key names help to avoid awkward mismatches between them and the value they represent.","spans":[]},{"type":"paragraph","text":"For example, let's assume we have a key name white in our model. Let's assume our app's default light theme expects this key to represent rgb(255, 255, 255) or #FFF. When authoring styles in this context, using this key name is easy to understand. ","spans":[{"start":45,"end":50,"type":"label","data":{"label":"code"}},{"start":138,"end":156,"type":"label","data":{"label":"code"}},{"start":160,"end":164,"type":"label","data":{"label":"code"}}]},{"type":"paragraph","text":"Now consider a different author intends to use our theme model with the underlying assumption the app's default theme is dark. The key name white should actually map to a relatively dark value. This becomes confusing and difficult to manage a mental map of each color key and their corresponding values.","spans":[{"start":140,"end":145,"type":"label","data":{"label":"code"}}]},{"type":"paragraph","text":"By using relativistic terms to describe our color keys, we can alleviate some of the cognitive load. Using a key name of background instead of white, it is more clear what value this is intended to represent in the context of any theme","spans":[{"start":121,"end":131,"type":"label","data":{"label":"code"}},{"start":143,"end":148,"type":"label","data":{"label":"code"}},{"start":226,"end":229,"type":"em"}]}]}},{"slice_type":"horizontal_rule","slice_label":null,"items":[{}],"primary":{}},{"slice_type":"section_title","slice_label":null,"items":[{}],"primary":{"section_title":[{"type":"heading3","text":"Theme Injection","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"Having now defined our base palette and theme maps, it's time to apply them as style rules to our document. To accomplish this, we will target the :root pseudo-class. This will cascade throughout the node tree of our document, insuring visibility to any descendent node hoping to leverage them.","spans":[{"start":147,"end":152,"type":"label","data":{"label":"code"}}]},{"type":"paragraph","text":"What precisely do we hope to define with these rules? We want to use our theme map to define CSS custom properties. ","spans":[]},{"type":"embed","oembed":{"url":"https://media.giphy.com/media/SvHWvk8oZAqc0/giphy.gif","embed_url":"https://media.giphy.com/media/SvHWvk8oZAqc0/giphy.gif","type":"rich","version":"1.0","title":null,"author_name":null,"author_url":null,"provider_name":"static_image","provider_url":null,"cache_age":null,"thumbnail_url":"https://media.giphy.com/media/SvHWvk8oZAqc0/giphy.gif","thumbnail_width":null,"thumbnail_height":null,"html":"<div data-type=\"static_image\"><img src=\"https://media.giphy.com/media/SvHWvk8oZAqc0/giphy.gif\"></div>"}},{"type":"paragraph","text":"Yes, I'm with you! Why CSS custom properties when we have the ability to leverage pre-processor variables? My thoughts on this are as follows:","spans":[]},{"type":"paragraph","text":"CSS pre-processors (such as Sass) evaluate and compile style rules precisely when the term suggests, at build time. Unfortunately, our style rules won't know which theme should be applied until a user loads the app. Unlike pre-processor variables, CSS custom properties are evaluated at run time. ","spans":[]},{"type":"paragraph","text":"If we can incorporate values generated at build-time into properties that can further be evaluated at run time, we can create variables that can use a single color key to author our styles, have them map to unique values depending on the current theme, and potentially allow further manipulation of the underlying value!","spans":[]},{"type":"paragraph","text":"I've already authored color mappings for each theme. I hope to avoid having to do that again when applying mapped values as explicit rules. So I intend to write a Sass mixin to generate each theme map as individual style rules. ","spans":[]}]}},{"slice_type":"code_snippet","slice_label":null,"items":[{}],"primary":{"filename":"./src/styles/themes.scss","highlight":"scss","code":[{"type":"preformatted","text":"@mixin map-css-custom-props-by-theme($theme) {\n  @each $color-key, $color in $theme {\n    --color-#{$color-key}: #{red($color), green($color), blue($color)};\n  }\n}","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"This mixin will iterate through each color key within our theme map and output a string representing a composed custom property name and the color primaries of its corresponding value. Note that the key name is formatted to support CSS custom property notation with additional namespacing to avoid any potential collisions. ","spans":[{"start":236,"end":260,"type":"hyperlink","data":{"link_type":"Web","url":"https://developer.mozilla.org/en-US/docs/Web/CSS/--*"}}]},{"type":"paragraph","text":"Why a string of just the color primaries? Why not map a complete and valid CSS color notation? ","spans":[]},{"type":"embed","oembed":{"url":"https://media.giphy.com/media/cwTtbmUwzPqx2/giphy.gif","embed_url":"https://media.giphy.com/media/cwTtbmUwzPqx2/giphy.gif","type":"rich","version":"1.0","title":null,"author_name":null,"author_url":null,"provider_name":"static_image","provider_url":null,"cache_age":null,"thumbnail_url":"https://media.giphy.com/media/cwTtbmUwzPqx2/giphy.gif","thumbnail_width":null,"thumbnail_height":null,"html":"<div data-type=\"static_image\"><img src=\"https://media.giphy.com/media/cwTtbmUwzPqx2/giphy.gif\"></div>"}},{"type":"paragraph","text":"CSS allows colors to be defined through either hexadecimal or functional notation. Unlike many color functions built into many pre-processors, CSS functional notation does not accept other expressions as parameters for additional manipulation.","spans":[{"start":47,"end":58,"type":"label","data":{"label":"code"}},{"start":62,"end":72,"type":"label","data":{"label":"code"}},{"start":72,"end":73,"type":"strong"}]},{"type":"paragraph","text":" For example, rgb(#ffccee) is not a valid CSS color, and would invalidate any rule attempting to express a color in such terms. By contrast, many pre-processors allow and encourage this type of expression. To circumvent this limitation, I hope to defer expressing a complete color until the moment it needs to be applied. ","spans":[{"start":14,"end":26,"type":"label","data":{"label":"code"}}]},{"type":"paragraph","text":"To accomplish this, we presume any expression of color will use functional notation. When the color is to be applied, its full CSS representation will compose a functional expression encapsulating a string representing its red, green, and blue components which are determined at run time.","spans":[]}]}},{"slice_type":"call-out","slice_label":null,"items":[{}],"primary":{"call_out_title":[{"type":"heading4","text":"Color notation footnote","spans":[]}],"rich_text":[{"type":"paragraph","text":"The CSS Color Module Level 4 specification does allow an 8-character hexadecimal notation, which would afford us the ability to compose additional alpha channel information to our palette values (defined in 6-digit hexadecimal notation). This would require us to express those channel values in a range of 00 to FF. I'm sure one could write a custom Sass function to map a more brain-friendly expression on a scale of 0-100 (or 0-1) to hexadecimal. For my purposes it is simpler to compose color opacity using functional notation.","spans":[{"start":4,"end":28,"type":"hyperlink","data":{"link_type":"Web","url":"https://www.w3.org/TR/css-color-4/#rgb-functions"}},{"start":43,"end":47,"type":"strong"},{"start":306,"end":308,"type":"label","data":{"label":"code"}},{"start":312,"end":314,"type":"label","data":{"label":"code"}}]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"Let's use this mixin to apply our themed CSS custom properties to our app.","spans":[]}]}},{"slice_type":"code_snippet","slice_label":null,"items":[{}],"primary":{"filename":"./src/styles/global.scss","highlight":"scss","code":[{"type":"preformatted","text":":root {\n  // other rules that may exist in the document root\n\n  // By default, map dark-mode theme variables\n  @include map-css-custom-props-by-theme($dark-theme);\n\n  // If user prefers light theme, apply light-theme variables instead\n  @media (prefers-color-scheme: light) {\n    @include map-css-custom-props-by-theme($light-theme);\n  }\n}","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"I'm using our aforementioned mixin to first define a default theme to be applied to our app. The mixin accepts a string argument representing the theme name, which then references the color model of that theme within our theme map variable. ","spans":[]},{"type":"paragraph","text":"A simple media query for prefers-color-scheme can be leveraged to determine whether the user's OS has specified a preference. The query is at the time of authoring this post rather widely supported, and will respond dynamically to any changes made to those preference settings in real time.","spans":[{"start":25,"end":45,"type":"label","data":{"label":"code"}},{"start":174,"end":198,"type":"hyperlink","data":{"link_type":"Web","url":"https://caniuse.com/#feat=prefers-color-scheme"}}]}]}},{"slice_type":"call-out","slice_label":null,"items":[{}],"primary":{"call_out_title":[{"type":"heading4","text":"The JavaScript option","spans":[]}],"rich_text":[{"type":"paragraph","text":"If you chose the JavaScript route, you are likely going to be interested in the window.matchMedia method. It similarly detects current OS appearance settings by parsing a mediaQueryString. Conveniently, one can also attach event listeners to detect changes associated with the query.","spans":[{"start":80,"end":98,"type":"label","data":{"label":"code"}},{"start":171,"end":187,"type":"label","data":{"label":"code"}}]}]}},{"slice_type":"horizontal_rule","slice_label":null,"items":[{}],"primary":{}},{"slice_type":"section_title","slice_label":null,"items":[{}],"primary":{"section_title":[{"type":"heading3","text":"Color referencing","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"Now that we have our CSS custom properties defined for each of our themes, how do we go about using them?","spans":[]},{"type":"paragraph","text":"Remember from earlier, our custom properties hold reference to a component string, not a complete and valid color expression. If we were to simply attempt to reference our custom properties by themselves, the entire rule would become invalid and summarily ignored by the browser.","spans":[]},{"type":"paragraph","text":"We can, however, write a Sass function which will compose a valid CSS color expression!","spans":[]},{"type":"embed","oembed":{"url":"https://media.giphy.com/media/cQNRp4QA8z7B6/giphy.gif","embed_url":"https://media.giphy.com/media/cQNRp4QA8z7B6/giphy.gif","type":"rich","version":"1.0","title":null,"author_name":null,"author_url":null,"provider_name":"static_image","provider_url":null,"cache_age":null,"thumbnail_url":"https://media.giphy.com/media/cQNRp4QA8z7B6/giphy.gif","thumbnail_width":null,"thumbnail_height":null,"html":"<div data-type=\"static_image\"><img src=\"https://media.giphy.com/media/cQNRp4QA8z7B6/giphy.gif\"></div>"}}]}},{"slice_type":"code_snippet","slice_label":null,"items":[{}],"primary":{"filename":"./src/styles/themes.scss","highlight":"scss","code":[{"type":"preformatted","text":"@function rgba-color($theme-color, $opacity: 1) {\n  @return RGBA(var(--color-#{$theme-color}), $opacity);\n}","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"I am defining a function here called rgba-color() which expects a required $theme-color argument and an optional $opacity argument which defaults to 1 (or full opacity). The function returns a CSS rgba() functional notation as expressed by Sass. It then wraps the $theme-color argument inside a var() function notation, and pre-fixed with a double-dash with a corresponding namespace tag. Any explicit, valid opacity values are included within the functional notation to represent a complete and valid CSS color.","spans":[{"start":37,"end":49,"type":"label","data":{"label":"code"}},{"start":75,"end":87,"type":"label","data":{"label":"code"}},{"start":113,"end":121,"type":"label","data":{"label":"code"}},{"start":197,"end":203,"type":"label","data":{"label":"code"}},{"start":264,"end":276,"type":"label","data":{"label":"code"}},{"start":295,"end":300,"type":"label","data":{"label":"code"}}]}]}},{"slice_type":"call-out","slice_label":null,"items":[{}],"primary":{"call_out_title":[{"type":"heading4","text":"Module dependency foootnote","spans":[]}],"rich_text":[{"type":"paragraph","text":"If you are using the latest version of lib-sass module in your project, there is no need for the distinction. Use capitalization if you cannot control your module dependency versions (such as authoring a pen in Codepen for example).","spans":[{"start":39,"end":47,"type":"label","data":{"label":"code"}},{"start":211,"end":218,"type":"hyperlink","data":{"link_type":"Web","url":"https://codepen.io/"}}]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"We can use this function to compose our style rules and even specify the value of a color's alpha component.","spans":[]}]}},{"slice_type":"code_snippet","slice_label":null,"items":[{}],"primary":{"filename":"./src/components/my-component.module.scss","highlight":"scss","code":[{"type":"preformatted","text":"/* \n  Assumes proper webpack configuration to support\n  aliases and resolving for .scss file extensions\n*/\n@import \"~styles/themes\"\n\n.my-component {\n  color: rgba-color(foreground);\n  background-color: rgba-color(background-0);\n  drop-shadow: 0 4px 8px rgba-color(foreground, 0.25);\n}","spans":[]}]}},{"slice_type":"article_content","slice_label":null,"items":[{}],"primary":{"rich_text":[{"type":"paragraph","text":"I'm now able to author styles using relativistic terminology as if I were authoring any other CSS color using functional notation. I can control the opacity of the color with the second parameter representing a valid CSS opacity value. I can compose statements with our color function as I would expect with any other CSS or Sass color type. And finally, I can author all of these rules without having to including numerous media queries to apply theme-specific values.","spans":[]},{"type":"paragraph","text":"If you want to see the full implementation of the concepts applied here, I've created a pen which puts this all to practice. As soon as Prismic figures out why oEmbeds coming from Codepen break on their platform, I'll have it embedded below","spans":[{"start":88,"end":91,"type":"hyperlink","data":{"link_type":"Web","url":"https://codepen.io/st0ven/pen/eYpOBBx"}}]}]}}]},"slug":"/articles/supporting-os-appearance-settings-in-your-web-app"}}}